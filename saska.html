<!DOCTYPE html>
<html lang="tk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Master Rus ≈ûa≈üka (Hard)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;500;700&display=swap');

        :root {
            --bg-color: #0f1115;
            --panel-bg: rgba(20, 25, 30, 0.95);
            --accent-color: #ff3d00;
            --accent-glow: #b22a00;
            --text-color: #ecf0f1;
            --board-border: #2d1b15;
            --wood-light: #e0c39c;
            --wood-dark: #5c4033;
        }

        body {
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at 50% 0%, #1f2530 0%, var(--bg-color) 80%);
            margin: 0;
            /* D√úZELTME: Mobilde kaydƒ±rmaya izin ver */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* justify-content: center; <-- Bunu kaldƒ±rdƒ±k ki √ºstten ba≈ülasƒ±n */
            font-family: 'Roboto', sans-serif;
            color: var(--text-color);
            overflow-y: auto; /* Dikey kaydƒ±rmaya izin ver */
            padding-bottom: 20px; /* Altta bo≈üluk bƒ±rak */
        }

        .watermark {
            margin-top: 10px;
            width: 100%;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.15);
            letter-spacing: 2px;
            pointer-events: none;
        }

        .main-layout {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            align-items: center; /* Ortala */
            flex-direction: column; /* Mobilde alt alta olsun */
            width: 100%;
        }

        .panel {
            background: var(--panel-bg);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.7);
            width: 90%; /* Mobilde geni≈ü olsun */
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        h2 { margin: 0 0 5px 0; font-size: 16px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; color: var(--accent-color); }

        .status-box {
            background: rgba(0,0,0,0.3);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
        }

        .mode-select {
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.2);
            padding: 5px;
            border-radius: 8px;
        }
        .mode-btn {
            flex: 1;
            padding: 8px;
            border: none;
            background: transparent;
            color: #aaa;
            cursor: pointer;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
            transition: 0.3s;
            text-transform: uppercase;
        }
        .mode-btn.active {
            background: var(--accent-color);
            color: white;
            box-shadow: 0 2px 10px rgba(255, 61, 0, 0.4);
        }

        .board-frame {
            padding: 10px;
            background: var(--board-border);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            position: relative;
            /* D√úZELTME: Mobilde ta≈ümamasƒ±nƒ± saƒüla */
            max-width: 95vw;
            overflow: hidden;
        }

        .board {
            display: grid;
            /* D√úZELTME: Kare boyutunu dinamik yap */
            grid-template-columns: repeat(8, 11vw);
            grid-template-rows: repeat(8, 11vw);
            border: 4px solid #1a100c;
            /* Maksimum boyut sƒ±nƒ±rƒ± koy (PC'de devasa olmasƒ±n) */
            max-width: 480px; 
            max-height: 480px;
        }
        
        /* PC i√ßin kare boyutunu sabitle */
        @media (min-width: 600px) {
            .board {
                grid-template-columns: repeat(8, 55px);
                grid-template-rows: repeat(8, 55px);
            }
            .cell { width: 55px !important; height: 55px !important; }
            .piece { width: 44px !important; height: 44px !important; }
            .main-layout { flex-direction: row; justify-content: center; align-items: flex-start; }
            .panel { width: 260px; }
        }

        .cell {
            width: 11vw; height: 11vw;
            position: relative;
            display: flex; justify-content: center; align-items: center;
        }
        .light { background: var(--wood-light); }
        .dark { background: var(--wood-dark); box-shadow: inset 0 0 10px rgba(0,0,0,0.6); }

        .piece {
            width: 8.5vw; height: 8.5vw; /* Mobilde orantƒ±lƒ± k√º√ß√ºlt */
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 3px 3px rgba(0,0,0,0.6), inset 0 -3px 3px rgba(0,0,0,0.5), inset 0 3px 6px rgba(255,255,255,0.4);
        }
        .piece.white { background: radial-gradient(circle at 30% 30%, #fff, #d7ccc8); border: 1px solid #aaa; }
        .piece.black { background: radial-gradient(circle at 30% 30%, #333, #000); border: 1px solid #222; }
        
        .piece.king::before {
            content: 'üëë'; font-size: 20px; position: absolute; /* Fontu k√º√ß√ºltt√ºk */
            top: 50%; left: 50%; transform: translate(-50%, -55%);
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.8));
        }
        .piece.white.king::before { color: #d35400; }
        .piece.black.king::before { color: #f1c40f; }

        .piece.selected { transform: scale(1.15); box-shadow: 0 0 15px var(--accent-color); z-index: 20; }
        .valid-move::after {
            content: ''; width: 14px; height: 14px;
            background: rgba(46, 204, 113, 0.8); border-radius: 50%;
            box-shadow: 0 0 8px #2ecc71; animation: pulse 1.5s infinite;
        }
        .valid-move { cursor: pointer; }
        .last-move { background: rgba(255, 61, 0, 0.25) !important; }

        @keyframes pulse { 0% { transform: scale(0.8); opacity: 0.6; } 50% { transform: scale(1.2); opacity: 1; } 100% { transform: scale(0.8); opacity: 0.6; } }

        button.restart-btn {
            background: linear-gradient(145deg, var(--accent-color), #bf360c);
            border: none; color: white; padding: 12px;
            border-radius: 6px; cursor: pointer; font-weight: bold; width: 100%;
            box-shadow: 0 4px 0 #870000; transition: transform 0.1s;
        }
        button.restart-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #870000; }
        
        .thinking {
            position: absolute; 
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); color: #ffcc00; 
            padding: 15px 30px; border-radius: 8px; border: 1px solid #ffcc00;
            display: none; z-index: 100; pointer-events: none;
            font-weight: bold; box-shadow: 0 0 20px rgba(255, 204, 0, 0.3);
            text-transform: uppercase; font-size: 14px;
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -60%); } to { opacity: 1; transform: translate(-50%, -50%); } }

    </style>
</head>
<body>

    <div class="watermark">@YouHapp_Robot</div>

    <div class="main-layout">
        
        <div class="panel">
            <h2>üèÜ ≈ûa≈üka Master</h2>
            
            <div class="mode-select">
                <button class="mode-btn active" id="btn-ai" onclick="setMode('ai')">ü§ñ AI (Zor)</button>
                <button class="mode-btn" id="btn-pvp" onclick="setMode('pvp')">üë• 2 Ki≈üi</button>
            </div>

            <div class="status-box" id="status-text" style="margin-top:10px;">Gezek: AKLAR</div>
            
            <div style="display:flex; justify-content:space-between; margin-top:10px;">
                <div style="text-align:center">
                    <span style="font-size:20px">‚ö™</span>
                    <div id="w-count">12</div>
                </div>
                <div style="text-align:center">
                    <span style="font-size:20px">‚ö´</span>
                    <div id="b-count">12</div>
                </div>
            </div>

            <button class="restart-btn" style="margin-top:15px;" onclick="initGame()">üîÑ O√Ωny Ba≈üla</button>
        </div>

        <div class="board-frame">
            <div class="board" id="board"></div>
            <div class="thinking" id="ai-thinking">ü§ñ Hasaplan√Ωar...</div>
        </div>

    </div>

    <script>
        const ROWS = 8, COLS = 8;
        let board = [];
        let turn = 1; // 1: Beyaz, 2: Siyah
        let gameMode = 'ai'; 
        let selectedCoords = null;
        let possibleMoves = [];
        let mustJumpFrom = null; 
        let lastMove = { from: null, to: null };
        let gameOver = false;
        
        // AI G√úC√ú
        const AI_DEPTH = 5; 

        // DOM
        const boardEl = document.getElementById('board');
        const statusEl = document.getElementById('status-text');
        const wCountEl = document.getElementById('w-count');
        const bCountEl = document.getElementById('b-count');
        const thinkingEl = document.getElementById('ai-thinking');
        const btnAi = document.getElementById('btn-ai');
        const btnPvP = document.getElementById('btn-pvp');

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            if(type === 'move') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0.01, now + 0.1);
            } else {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                gain.gain.setValueAtTime(0.4, now); gain.gain.linearRampToValueAtTime(0.01, now + 0.15);
            }
            osc.start(now); osc.stop(now + 0.15);
        }

        function setMode(mode) {
            gameMode = mode;
            if(mode === 'ai') { btnAi.classList.add('active'); btnPvP.classList.remove('active'); } 
            else { btnPvP.classList.add('active'); btnAi.classList.remove('active'); }
            initGame();
        }

        function initGame() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            for(let r=0; r<ROWS; r++) {
                for(let c=0; c<COLS; c++) {
                    if((r+c)%2 !== 0) {
                        if(r < 3) board[r][c] = 2; // Siyah
                        if(r > 4) board[r][c] = 1; // Beyaz
                    }
                }
            }
            turn = 1; gameOver = false; selectedCoords = null; possibleMoves = [];
            mustJumpFrom = null; lastMove = {from: null, to: null};
            updateUI(); renderBoard();
        }

        function isWhite(p) { return p === 1 || p === 3; }
        function isKing(p) { return p === 3 || p === 4; }
        function cloneBoard(b) { return b.map(row => [...row]); }

        function getMoves(b, r, c, checkJumpsOnly = false) {
            const p = b[r][c]; if(p === 0) return [];
            const moves = []; const king = isKing(p); const white = isWhite(p);
            const dirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];

            for(let d of dirs) {
                let dr = d[0], dc = d[1]; let dist = 1;
                while(true) {
                    let nr = r + dr*dist, nc = c + dc*dist;
                    if(nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
                    if(b[nr][nc] === 0) {
                        if(!checkJumpsOnly) {
                            let canMove = king;
                            if(!king) { if(white && dr === -1) canMove = true; if(!white && dr === 1) canMove = true; }
                            if(canMove) moves.push({fromR: r, fromC: c, r: nr, c: nc, type: 'move'});
                        }
                    } else {
                        if(isWhite(b[nr][nc]) !== white) {
                            let jr = nr + dr, jc = nc + dc;
                            while(true) {
                                if(jr < 0 || jr >= ROWS || jc < 0 || jc >= COLS) break;
                                if(b[jr][jc] === 0) {
                                    moves.push({fromR: r, fromC: c, r: jr, c: jc, type: 'jump', killedR: nr, killedC: nc});
                                    if(!king) break;
                                } else break;
                                if(!king) break; jr += dr; jc += dc;
                            }
                        } break;
                    } if(!king) break; dist++;
                }
            } return moves;
        }

        function getAllMoves(b, player) {
            let moves = [], jumps = [];
            for(let r=0; r<ROWS; r++) {
                for(let c=0; c<COLS; c++) {
                    const p = b[r][c]; if(p === 0) continue;
                    if((isWhite(p) ? 1 : 2) === player) {
                        const ms = getMoves(b, r, c);
                        ms.forEach(m => { if(m.type === 'jump') jumps.push(m); else moves.push(m); });
                    }
                }
            } return jumps.length > 0 ? jumps : moves;
        }

        function applyMove(b, move) {
            const p = b[move.fromR][move.fromC];
            b[move.fromR][move.fromC] = 0; b[move.r][move.c] = p;
            if(move.type === 'jump') b[move.killedR][move.killedC] = 0;
            if(p === 1 && move.r === 0) b[move.r][move.c] = 3;
            if(p === 2 && move.r === 7) b[move.r][move.c] = 4;
            return b;
        }

        function evaluateBoard(b) {
            let score = 0;
            for(let r=0; r<ROWS; r++) {
                for(let c=0; c<COLS; c++) {
                    const p = b[r][c]; if(p === 0) continue;
                    
                    let val = (p === 1 || p === 2) ? 100 : 500; 
                    if(p === 2) val += r * 5;      
                    if(p === 1) val += (7-r) * 5;  
                    if(c === 0 || c === 7) val += 10;
                    if(p === 2 && r === 0) val += 30; 
                    if(p === 1 && r === 7) val += 30;
                    if(r >= 3 && r <= 4 && c >= 2 && c <= 5) val += 20;

                    if(isWhite(p)) score -= val; else score += val;
                }
            }
            return score;
        }

        function minimax(b, depth, isMaximizing, alpha, beta) {
            if(depth === 0) return evaluateBoard(b);
            const player = isMaximizing ? 2 : 1;
            const moves = getAllMoves(b, player);
            if(moves.length === 0) return isMaximizing ? -10000 : 10000;

            if(isMaximizing) {
                let maxEval = -Infinity;
                for(let move of moves) {
                    const newBoard = cloneBoard(b); applyMove(newBoard, move);
                    const ev = minimax(newBoard, depth - 1, false, alpha, beta);
                    maxEval = Math.max(maxEval, ev); alpha = Math.max(alpha, ev);
                    if(beta <= alpha) break;
                } return maxEval;
            } else {
                let minEval = Infinity;
                for(let move of moves) {
                    const newBoard = cloneBoard(b); applyMove(newBoard, move);
                    const ev = minimax(newBoard, depth - 1, true, alpha, beta);
                    minEval = Math.min(minEval, ev); beta = Math.min(beta, ev);
                    if(beta <= alpha) break;
                } return minEval;
            }
        }

        async function aiTurn() {
            thinkingEl.style.display = 'block';
            setTimeout(() => {
                const moves = getAllMoves(board, 2);
                if(moves.length === 0) {
                    alert("Tebrikler! Kazandƒ±nƒ±z!"); gameOver = true; thinkingEl.style.display = 'none'; return;
                }

                let bestMove = moves[0];
                if(moves.length > 1) {
                    let bestValue = -Infinity;
                    for(let move of moves) {
                        const newBoard = cloneBoard(board); applyMove(newBoard, move);
                        let moveBonus = (move.type === 'jump') ? 50 : 0;
                        moveBonus += Math.random() * 5; 
                        const boardVal = minimax(newBoard, AI_DEPTH, false, -Infinity, Infinity) + moveBonus;
                        if(boardVal > bestValue) { bestValue = boardVal; bestMove = move; }
                    }
                }

                if(bestMove) {
                    selectedCoords = { r: bestMove.fromR, c: bestMove.fromC };
                    executeMove(bestMove);
                }
                thinkingEl.style.display = 'none';
            }, 800);
        }

        function handleSquareClick(r, c) {
            if(gameOver) return;
            if(gameMode === 'ai' && turn === 2) return;

            const p = board[r][c];
            if(p !== 0 && ((turn === 1 && isWhite(p)) || (turn === 2 && !isWhite(p)))) {
                if(mustJumpFrom && (mustJumpFrom.r !== r || mustJumpFrom.c !== c)) return;
                const all = getAllMoves(board, turn);
                const canSelect = all.some(m => m.fromR === r && m.fromC === c);
                if(canSelect) {
                    selectedCoords = {r, c};
                    possibleMoves = all.filter(m => m.fromR === r && m.fromC === c);
                    renderBoard();
                }
                return;
            }

            if(selectedCoords) {
                const move = possibleMoves.find(m => m.r === r && m.c === c);
                if(move) executeMove(move);
                else if(!mustJumpFrom) { selectedCoords = null; possibleMoves = []; renderBoard(); }
            }
        }

        function executeMove(move) {
            const piece = board[move.fromR][move.fromC];
            board[move.fromR][move.fromC] = 0; board[move.r][move.c] = piece;
            if(move.type === 'jump') { board[move.killedR][move.killedC] = 0; playSound('capture'); } 
            else playSound('move');

            if(piece === 1 && move.r === 0) board[move.r][move.c] = 3;
            if(piece === 2 && move.r === 7) board[move.r][move.c] = 4;
            lastMove = { from: {r: move.fromR, c: move.fromC}, to: {r: move.r, c: move.c} };

            let chainMoves = [];
            if(move.type === 'jump') chainMoves = getMoves(board, move.r, move.c, true);

            if(chainMoves.length > 0) {
                mustJumpFrom = {r: move.r, c: move.c};
                
                if(gameMode === 'ai' && turn === 2) {
                    setTimeout(() => {
                        selectedCoords = {r: move.r, c: move.c};
                        executeMove(chainMoves[0]);
                    }, 800);
                } else {
                    selectedCoords = {r: move.r, c: move.c};
                    possibleMoves = chainMoves;
                }
                renderBoard();
                return;
            }

            mustJumpFrom = null; selectedCoords = null; possibleMoves = [];
            turn = turn === 1 ? 2 : 1;
            updateUI(); renderBoard();

            const opponentMoves = getAllMoves(board, turn);
            if(opponentMoves.length === 0) {
                setTimeout(() => {
                    const winner = turn === 1 ? (gameMode === 'ai' ? "Siyah (AI)" : "Siyah") : "Beyaz";
                    alert(`${winner} Kazandƒ±!`); gameOver = true;
                }, 200);
                return;
            }

            if(gameMode === 'ai' && turn === 2 && !gameOver) aiTurn();
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            let w = 0, b = 0;
            for(let r=0; r<ROWS; r++) {
                for(let c=0; c<COLS; c++) {
                    const val = board[r][c];
                    if(isWhite(val)) w++; else if(val !== 0) b++;
                    const cell = document.createElement('div');
                    cell.className = `cell ${(r+c)%2===0 ? 'light' : 'dark'}`;
                    if(lastMove.from && lastMove.from.r === r && lastMove.from.c === c) cell.classList.add('last-move');
                    if(lastMove.to && lastMove.to.r === r && lastMove.to.c === c) cell.classList.add('last-move');
                    const move = possibleMoves.find(m => m.r === r && m.c === c);
                    if(move) { cell.classList.add('valid-move'); cell.onclick = () => executeMove(move); }
                    else cell.onclick = () => handleSquareClick(r, c);

                    if(val !== 0) {
                        const p = document.createElement('div');
                        p.className = `piece ${isWhite(val) ? 'white' : 'black'} ${isKing(val) ? 'king' : ''}`;
                        if(selectedCoords && selectedCoords.r === r && selectedCoords.c === c) p.classList.add('selected');
                        const canClick = (turn === 1 && isWhite(val)) || (turn === 2 && !isWhite(val));
                        if(gameMode === 'ai' && turn === 2) {} 
                        else if (!canClick) p.style.pointerEvents = 'none';
                        cell.appendChild(p);
                    }
                    boardEl.appendChild(cell);
                }
            }
            wCountEl.innerText = w; bCountEl.innerText = b;
        }

        function updateUI() {
            let tText = "";
            if(turn === 1) tText = "Gezek: AKLAR";
            else tText = gameMode === 'ai' ? "Gezek: KOMP√ùUTER" : "Gezek: GARALAR";
            statusEl.innerText = tText;
            statusEl.style.color = turn === 1 ? "#ecf0f1" : "#e67e22";
        }

        initGame();
    </script>
</body>
</html>
